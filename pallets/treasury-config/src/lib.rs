#![cfg_attr(not(feature = "std"), no_std)]
#![doc = "# Treasury Config Pallet"]
#![doc = ""]
#![doc = "This pallet manages the treasury multisig configuration."]
#![doc = "It stores the signatories and threshold for the treasury multisig account,"]
#![doc = "and provides deterministic address generation."]

extern crate alloc;

pub use pallet::*;
pub use weights::WeightInfo;

#[cfg(test)]
mod mock;
#[cfg(test)]
mod tests;

#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;

pub mod weights;

// Allow expect_used in pallet macro expansions - these are auto-generated by frame_support
#[allow(clippy::expect_used)]
#[frame_support::pallet]
pub mod pallet {
	use crate::WeightInfo;
	use alloc::vec::Vec;
	use frame_support::{pallet_prelude::*, traits::Get};
	use frame_system::pallet_prelude::*;
	use sp_runtime::traits::Hash;

	#[pallet::pallet]
	pub struct Pallet<T>(_);

	#[pallet::config]
	pub trait Config: frame_system::Config<RuntimeEvent: From<Event<Self>>> {
		/// Maximum number of signatories allowed.
		type MaxSignatories: Get<u32>;

		/// Weight information for extrinsics in this pallet.
		type WeightInfo: WeightInfo;
	}

	/// The list of signatories for the treasury multisig account.
	/// This is set in genesis and can be updated via governance.
	#[pallet::storage]
	#[pallet::getter(fn signatories)]
	pub type Signatories<T: Config> =
		StorageValue<_, BoundedVec<T::AccountId, T::MaxSignatories>, ValueQuery>;

	/// The threshold of signatures required for the treasury multisig.
	/// This is set in genesis and can be updated via governance.
	#[pallet::storage]
	#[pallet::getter(fn threshold)]
	pub type Threshold<T: Config> = StorageValue<_, u16, ValueQuery>;

	#[pallet::genesis_config]
	#[derive(frame_support::DefaultNoBound)]
	pub struct GenesisConfig<T: Config> {
		pub signatories: Vec<T::AccountId>,
		pub threshold: u16,
	}

	#[pallet::genesis_build]
	impl<T: Config> BuildGenesisConfig for GenesisConfig<T> {
		fn build(&self) {
			// Validate signatories
			if self.signatories.is_empty() {
				// Genesis build errors are acceptable - this only runs once during chain init
				#[cfg(feature = "std")]
				eprintln!("ERROR: Treasury signatories cannot be empty");
				return;
			}

			// Validate threshold
			if self.threshold == 0 || self.threshold as usize > self.signatories.len() {
				#[cfg(feature = "std")]
				eprintln!(
					"ERROR: Invalid threshold {} for {} signatories",
					self.threshold,
					self.signatories.len()
				);
				return;
			}

			// Convert to bounded vec
			let bounded_signatories = match BoundedVec::try_from(self.signatories.clone()) {
				Ok(bounded) => bounded,
				Err(_) => {
					#[cfg(feature = "std")]
					eprintln!(
						"ERROR: Treasury signatories ({}) exceed maximum limit ({})",
						self.signatories.len(),
						T::MaxSignatories::get()
					);
					return;
				},
			};

			Signatories::<T>::put(bounded_signatories);
			Threshold::<T>::put(self.threshold);
		}
	}

	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
		/// Treasury signatories have been updated. [old_account, new_account]
		TreasurySignatoriesUpdated { old_account: T::AccountId, new_account: T::AccountId },
	}

	#[pallet::call]
	impl<T: Config> Pallet<T> {
		/// Update the treasury signatories and threshold in a single call.
		/// This requires Root origin (typically via governance/tech referenda).
		///
		/// This updates ALL signatories at once - you provide the complete new list.
		/// Example: To change from 5 signatories to different 5 signatories with new threshold,
		/// you call this once with the new Vec<AccountId> and new threshold.
		///
		/// Emits `TreasurySignatoriesUpdated` event showing the old and new multisig addresses.
		#[pallet::call_index(0)]
		#[pallet::weight(T::WeightInfo::set_treasury_signatories(signatories.len() as u32))]
		pub fn set_treasury_signatories(
			origin: OriginFor<T>,
			signatories: Vec<T::AccountId>,
			threshold: u16,
		) -> DispatchResult {
			ensure_root(origin)?;

			ensure!(!signatories.is_empty(), Error::<T>::EmptySignatories);
			ensure!(
				threshold > 0 && threshold as usize <= signatories.len(),
				Error::<T>::InvalidThreshold
			);

			// Store old address for event
			let old_account = Self::get_treasury_account();

			// Update storage
			let bounded_signatories =
				BoundedVec::try_from(signatories).map_err(|_| Error::<T>::TooManySignatories)?;

			Signatories::<T>::put(bounded_signatories);
			Threshold::<T>::put(threshold);

			// Calculate new address
			let new_account = Self::get_treasury_account();

			// Emit event
			Self::deposit_event(Event::TreasurySignatoriesUpdated { old_account, new_account });

			Ok(())
		}
	}

	#[pallet::error]
	pub enum Error<T> {
		/// The signatories list is empty.
		EmptySignatories,
		/// The threshold is invalid (0 or greater than number of signatories).
		InvalidThreshold,
		/// Too many signatories provided.
		TooManySignatories,
	}

	impl<T: Config> Pallet<T> {
		/// Calculate the multisig address from current signatories and threshold.
		/// This uses the same algorithm as pallet-multisig for deterministic address generation.
		pub fn get_treasury_account() -> T::AccountId {
			let signatories = Signatories::<T>::get();
			let threshold = Threshold::<T>::get();

			// If not configured yet, return default account
			if signatories.is_empty() || threshold == 0 {
				return match T::AccountId::decode(
					&mut sp_runtime::traits::TrailingZeroInput::zeroes(),
				) {
					Ok(account) => account,
					Err(_) => {
						// This should never happen with TrailingZeroInput
						// Return a deterministic fallback
						Self::multi_account_id(&[], 0)
					},
				};
			}

			Self::multi_account_id(&signatories.into_inner(), threshold)
		}

		/// Generate multisig account ID from signatories and threshold.
		/// This matches the algorithm used by pallet-multisig.
		fn multi_account_id(who: &[T::AccountId], threshold: u16) -> T::AccountId {
			let entropy = (b"modlpy/utilisuba", who, threshold).using_encoded(T::Hashing::hash);
			// Hash output is always valid input for AccountId decode
			// This operation cannot fail in practice, but we handle the Result to satisfy clippy
			T::AccountId::decode(&mut entropy.as_ref()).unwrap_or_else(|_| {
				// Extremely unlikely fallback: decode from trailing zeros
				// If even this fails, we recursively call with empty data
				T::AccountId::decode(&mut sp_runtime::traits::TrailingZeroInput::zeroes())
					.unwrap_or_else(|_| Self::multi_account_id(&[], 0))
			})
		}
	}

	/// Implement Get<AccountId> so this can be used as parameter_types! replacement
	pub struct TreasuryAccount<T>(core::marker::PhantomData<T>);

	impl<T: Config> Get<T::AccountId> for TreasuryAccount<T> {
		fn get() -> T::AccountId {
			Pallet::<T>::get_treasury_account()
		}
	}
}
