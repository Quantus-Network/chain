name: Create Release

env:
  CARGO_TERM_COLOR: always

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Type of version bump (major, minor, patch) or specify custom version. For 0.x.y releases, major will bump 0.x -> 0.(x+1)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
          - custom
      custom_version:
        description: 'Custom version string (e.g., v1.2.3 or v0.2.1-beta.1). Only used if version_type is "custom". MUST start with "v" (e.g. v1.2.3)'
        required: false
      is_prerelease:
        description: 'Is this a pre-release? (e.g., alpha, beta, rc)'
        required: true
        type: boolean
        default: false
      prerelease_identifier:
        description: 'Pre-release identifier (e.g., alpha, beta, rc). Only used if is_prerelease is true.'
        required: false
        default: 'rc'
      draft_release:
        description: 'Create the release as a draft?'
        required: true
        type: boolean
        default: true
      fast_test_create_release_job:
        description: 'If true, skips actual build and uses dummy artifacts to test release creation steps.'
        required: false
        type: boolean
        default: false
      is_runtime_upgrade:
        description: 'Is this a runtime upgrade release?'
        required: true
        type: boolean
        default: false
      runtime_upgrade_suffix:
        description: 'Suffix for runtime upgrade version (e.g., dead-cat). Only used if is_runtime_upgrade is true.'
        required: false
        default: ''

jobs:
  calculate-next-version:
    name: üßÆ Calculate Next Version
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.versioner.outputs.new_version }}
      commit_sha_short: ${{ steps.vars.outputs.commit_sha_short }}
      branch_name: ${{ steps.vars.outputs.branch_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Get current branch and commit SHA
        id: vars
        run: |
          echo "commit_sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "branch_name=$(git rev-parse --abbrev-ref HEAD)" >> $GITHUB_OUTPUT

      - name: Get latest tag
        id: latest_tag
        run: |
          # Get all version tags and sort them by version
          latest_semver_tag=$(git tag -l "v[0-9]*.[0-9]*.[0-9]*" | sort -V | tail -n 1)
          
          # If no tags found, use default
          if [ -z "$latest_semver_tag" ]; then
            latest_semver_tag="v0.0.0"
          fi
          
          echo "latest_tag_found=$latest_semver_tag" >> $GITHUB_OUTPUT
          echo "Latest semantic version tag found: $latest_semver_tag"

      - name: Calculate new version
        id: versioner
        env:
          LATEST_TAG: ${{ steps.latest_tag.outputs.latest_tag_found }}
          VERSION_TYPE: ${{ github.event.inputs.version_type }}
          CUSTOM_VERSION: ${{ github.event.inputs.custom_version }}
          IS_PRERELEASE: ${{ github.event.inputs.is_prerelease }}
          PRERELEASE_ID: ${{ github.event.inputs.prerelease_identifier }}
          IS_RUNTIME_UPGRADE: ${{ github.event.inputs.is_runtime_upgrade }}
          RUNTIME_SUFFIX: ${{ github.event.inputs.runtime_upgrade_suffix }}
        run: |
          # Remove 'v' prefix and any suffix for processing
          current_version=${LATEST_TAG#v}
          # Remove any suffix after the version number
          current_version=$(echo "$current_version" | sed -E 's/-[^-]+$//')

          if [[ "$VERSION_TYPE" == "custom" ]]; then
            if [[ -z "$CUSTOM_VERSION" ]]; then
              echo "Error: Custom version is selected but no custom_version string provided."
              exit 1
            fi
            if [[ ! "$CUSTOM_VERSION" =~ ^v ]]; then
              echo "Error: Custom version string MUST start with 'v' (e.g., v1.2.3)."
              exit 1
            fi
            new_version="$CUSTOM_VERSION"
          else
            # Split version and pre-release part
            IFS='-' read -r version_core prerelease_part <<< "$current_version"
            IFS='.' read -r major minor patch <<< "$version_core"

            # Increment based on type
            if [[ "$VERSION_TYPE" == "major" ]]; then
              if [[ "$major" == "0" ]]; then # Handle 0.x.y -> 0.(x+1).0
                major=$major
                minor=$((minor + 1))
                patch=0
              else
                major=$((major + 1))
                minor=0
                patch=0
              fi
            elif [[ "$VERSION_TYPE" == "minor" ]]; then
              minor=$((minor + 1))
              patch=0
            elif [[ "$VERSION_TYPE" == "patch" ]]; then
              patch=$((patch + 1))
            else
              echo "Error: Invalid version_type: $VERSION_TYPE"
              exit 1
            fi
            new_version_core="v$major.$minor.$patch"

            if [[ "$IS_PRERELEASE" == "true" ]]; then
              prerelease_num=1
              # If current was a prerelease of the same core and same ID, increment number
              if [[ "$prerelease_part" =~ ^$PRERELEASE_ID\\.([0-9]+)$ ]]; then
                prerelease_num=1 # Simplified: always start at .1 for new core version
              elif [[ "$prerelease_part" =~ ^$PRERELEASE_ID$ ]]; then
                 prerelease_num=1 # also start at .1 if it was just "alpha"
              fi
              new_version="$new_version_core-$PRERELEASE_ID.$prerelease_num"
            else
              new_version="$new_version_core"
            fi
          fi

          # Add runtime upgrade suffix if needed
          if [[ "$IS_RUNTIME_UPGRADE" == "true" ]]; then
            new_version="${new_version}-$RUNTIME_SUFFIX"
          fi

          echo "New version: $new_version"
          echo "new_version=$new_version" >> $GITHUB_OUTPUT

  update-cargo-toml:
    name: üìù Update version files
    needs: calculate-next-version
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create version bump branch and PR
        env:
          NEW_VERSION_WITH_V: ${{ needs.calculate-next-version.outputs.new_version }}
          GITHUB_TOKEN: ${{ secrets.ADMIN_PAT }}
        run: |
          set -ex
          new_cargo_version=${NEW_VERSION_WITH_V#v}
          branch_name="release/${NEW_VERSION_WITH_V}"

          git checkout -b "$branch_name"
          
          # Always update node version
          echo "Updating node/Cargo.toml to version: $new_cargo_version"
          sed -i -E "s/^version\s*=\s*\"[0-9a-zA-Z.-]+\"/version = \"$new_cargo_version\"/" node/Cargo.toml
          
          # For runtime upgrade, also update runtime version and increment spec_version
          if [[ "${{ github.event.inputs.is_runtime_upgrade }}" == "true" ]]; then
            echo "Runtime upgrade detected. Updating runtime/Cargo.toml and incrementing spec_version..."
            sed -i -E "s/^version\s*=\s*\"[0-9a-zA-Z.-]+\"/version = \"$new_cargo_version\"/" runtime/Cargo.toml
          
            # Increment spec_version
            current_spec_version=$(grep -o 'spec_version: [0-9]*' runtime/src/lib.rs | awk '{print $2}')
            new_spec_version=$((current_spec_version + 1))
            sed -i -E "s/spec_version: [0-9]*/spec_version: $new_spec_version/" runtime/src/lib.rs
          fi
          
          # Update Cargo.lock
          cargo update -p quantus-node --precise "$new_cargo_version" || echo "cargo update -p quantus-node tried, proceeding."
          if [[ "${{ github.event.inputs.is_runtime_upgrade }}" == "true" ]]; then
            cargo update -p quantus-runtime --precise "$new_cargo_version" || echo "cargo update -p quantus-runtime tried, proceeding."
          fi

          # Commit changes
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"
          
          git add node/Cargo.toml Cargo.lock
          if [[ "${{ github.event.inputs.is_runtime_upgrade }}" == "true" ]]; then
            git add runtime/Cargo.toml runtime/src/lib.rs
          fi
          
          git commit -m "ci: Automate version bump to $NEW_VERSION_WITH_V"
          git push origin "$branch_name"

          gh pr create \
            --title "ci: Automate version bump to $NEW_VERSION_WITH_V" \
            --body "$(printf "Automated version bump for release %s.\\n\\nTriggered by workflow run: %s" "$NEW_VERSION_WITH_V" "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}")" \
            --base main \
            --head "$branch_name" \
            --label "version-bump,automated"

  build-and-package:
    name: üèóÔ∏è Build & Package (Linux, macOS, Windows)
    needs: [calculate-next-version, update-cargo-toml]
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
          - target: aarch64-apple-darwin
            os: macos-latest
          - target: x86_64-pc-windows-msvc
            os: windows-latest
    outputs:
      release_assets_json: ${{ steps.prepare_assets.outputs.release_assets_json }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install protoc (protobuf-compiler) for Linux
        if: runner.os == 'Linux'
        run: sudo apt-get update && sudo apt-get install -y protobuf-compiler

      - name: Install protoc (protobuf-compiler) for macOS
        if: runner.os == 'macOS'
        run: brew install protobuf

      - name: Install protoc (protobuf-compiler) for Windows
        if: runner.os == 'Windows'
        run: choco install protoc --yes --no-progress

      - name: Install Rust toolchain
        shell: bash
        env:
          RUST_COMPONENTS: "rustfmt,clippy,rust-src"
          RUST_TARGETS_ADDITIONAL: "wasm32-unknown-unknown"
        run: |
          set -e
          TOOLCHAIN_NIGHTLY_VERSION="nightly-2024-12-24"
          echo "Installing toolchain: $TOOLCHAIN_NIGHTLY_VERSION"
          echo "With components: $RUST_COMPONENTS"
          echo "With targets for matrix.target (${{ matrix.target }}): already included in install cmd."
          echo "With additional targets: $RUST_TARGETS_ADDITIONAL"

          CMD_TOOLCHAIN_INSTALL="rustup toolchain install $TOOLCHAIN_NIGHTLY_VERSION --profile minimal --no-self-update --target ${{ matrix.target }}"
          CMD_COMPONENTS_ADD="rustup component add $(echo $RUST_COMPONENTS | sed 's/,/ /g') --toolchain $TOOLCHAIN_NIGHTLY_VERSION"
          CMD_TARGET_ADD="rustup target add $RUST_TARGETS_ADDITIONAL --toolchain $TOOLCHAIN_NIGHTLY_VERSION"

          FULL_COMMAND="$CMD_TOOLCHAIN_INSTALL && $CMD_COMPONENTS_ADD && $CMD_TARGET_ADD"

          MAX_ATTEMPTS=3
          ATTEMPT_NUM=1
          SUCCESS=false
          while [ $ATTEMPT_NUM -le $MAX_ATTEMPTS ]; do
            echo "Attempt $ATTEMPT_NUM/$MAX_ATTEMPTS: Running toolchain installation..."
            if (eval "$FULL_COMMAND"); then
              SUCCESS=true
              echo "Toolchain installation successful."
              break
            fi
            echo "Attempt $ATTEMPT_NUM failed."
            ATTEMPT_NUM=$((ATTEMPT_NUM+1))
            if [ $ATTEMPT_NUM -gt $MAX_ATTEMPTS ]; then
              echo "All $MAX_ATTEMPTS attempts failed to install Rust toolchain."
              exit 1
            fi
            echo "Retrying in 30 seconds..."
            sleep 30
          done

          if [ "$SUCCESS" = false ]; then
            echo "Critical error: Toolchain installation marked as failed despite loop completion logic."
            exit 1
          fi

          rustup default $TOOLCHAIN_NIGHTLY_VERSION
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
          echo "RUSTUP_TOOLCHAIN=$TOOLCHAIN_NIGHTLY_VERSION" >> $GITHUB_ENV
          echo "Installed Rust toolchain: $(rustc --version)"

      - name: Build quantus-node binary
        if: github.event.inputs.fast_test_create_release_job == 'false'
        run: cargo build --release --package quantus-node --target ${{ matrix.target }}

      - name: Create dummy quantus-node binary (fast test mode)
        if: github.event.inputs.fast_test_create_release_job == 'true' && (runner.os == 'Linux' || runner.os == 'macOS')
        run: |
          mkdir -p target/${{ matrix.target }}/release
          echo "This is a dummy quantus-node for fast testing (${{ matrix.target }}). Actual build skipped." > target/${{ matrix.target }}/release/quantus-node
          chmod +x target/${{ matrix.target }}/release/quantus-node
          echo "Dummy quantus-node created at target/${{ matrix.target }}/release/quantus-node"

      - name: Create dummy quantus-node.exe binary (for fast test Windows)
        if: github.event.inputs.fast_test_create_release_job == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $dummy_dir = "target/${{ matrix.target }}/release"
          New-Item -ItemType Directory -Path $dummy_dir -Force | Out-Null
          Set-Content -Path "$dummy_dir/quantus-node.exe" -Value "This is a dummy quantus-node.exe for fast testing (${{ matrix.target }}). Actual build skipped."
          Write-Host "Dummy quantus-node.exe created at $dummy_dir/quantus-node.exe"

      - name: Prepare Release Assets
        id: prepare_assets
        env:
          NEW_VERSION: ${{ needs.calculate-next-version.outputs.new_version }}
          TARGET_ARCH: ${{ matrix.target }}
        shell: bash
        run: |
          NODE_BASE_NAME="quantus-node"
          
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            NODE_EXECUTABLE_NAME="${NODE_BASE_NAME}.exe"
            ARCHIVE_EXTENSION="zip"
            CHSUM_EXEC="powershell -Command \"(Get-FileHash -Algorithm SHA256 '\${asset_name}').Hash.ToLower() + ' *\${asset_name}' | Set-Content -Encoding ascii '\${checksum_file_name}'\""
            ARCHIVE_EXEC="powershell -Command \"Compress-Archive -Path staging/\${NODE_EXECUTABLE_NAME} -DestinationPath \${asset_name}\""
          
            asset_name="${NODE_BASE_NAME}-${NEW_VERSION}-${TARGET_ARCH}.${ARCHIVE_EXTENSION}"
            checksum_file_name="sha256sums-${NEW_VERSION}-${TARGET_ARCH}.txt"

            mkdir -p staging
            cp "target/${TARGET_ARCH}/release/${NODE_EXECUTABLE_NAME}" "staging/"
          
            eval "$ARCHIVE_EXEC"
            eval "$CHSUM_EXEC"

          else
            NODE_BINARY_NAME="quantus-node"
            asset_name="${NODE_BINARY_NAME}-${NEW_VERSION}-${TARGET_ARCH}.tar.gz"
            checksum_file_name="sha256sums-${NEW_VERSION}-${TARGET_ARCH}.txt"

            mkdir staging
            cp target/${TARGET_ARCH}/release/${NODE_BINARY_NAME} staging/
          
            (cd staging && tar -czvf "../${asset_name}" ${NODE_BINARY_NAME})
          
            if [[ "${{ runner.os }}" == "macOS" ]]; then
              shasum -a 256 "${asset_name}" > "${checksum_file_name}"
            else
              sha256sum "${asset_name}" > "${checksum_file_name}"
            fi          
          fi

          echo "Created asset: ${asset_name}"
          echo "Created checksum file: ${checksum_file_name}"

          asset_paths_json="[\\"${asset_name}\\", \\"${checksum_file_name}\\"]"
          echo "release_assets_json=${asset_paths_json}" >> $GITHUB_OUTPUT
          ls -la

      - name: Upload Release Assets as Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-assets-${{ matrix.target }}
          path: |
            quantus-node-${{ needs.calculate-next-version.outputs.new_version }}-${{ matrix.target }}.${{ runner.os == 'Windows' && 'zip' || 'tar.gz' }}
            sha256sums-${{ needs.calculate-next-version.outputs.new_version }}-${{ matrix.target }}.txt

  build-runtime:
    name: üß© Build Runtime (srtool)
    if: github.event.inputs.is_runtime_upgrade == 'true'
    timeout-minutes: 180
    needs: [calculate-next-version, update-cargo-toml]
    runs-on: ubuntu-22.04
    env:
      CARGO_TERM_COLOR: always
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: cache target dir
        uses: actions/cache@v4
        with:
          path: "$GITHUB_WORKSPACE/runtime/target"
          key: srtool-target-${{ github.sha }}
          restore-keys: |
            srtool-target-
      - name: build runtime
        id: srtool-build
        shell: bash
        run: |
          set -eo pipefail
          
          echo "::group::Executing srtool command"
          
          JSON_OUTPUT=$(docker run --rm \
            -e RUSTC_BOOTSTRAP=1 \
            -e RUSTC_VERSION="${{ github.event.inputs.rust_version }}" \
            -e PACKAGE="quantus-runtime" \
            -e RUNTIME_DIR="runtime" \
            -e "BUILD_OPTS=--features on-chain-release-build" \
            -e PROFILE="release" \
            -v "$(pwd):/build" \
            -v "/tmp/cargo:/cargo-home" \
            paritytech/srtool:1.84.1 \
            build --app --json -cM \
            | tee /dev/stderr | tail -n 1)

          echo "::endgroup::"
          
          # Check if JSON is valid
          if ! echo "$JSON_OUTPUT" | jq .; then
            echo "::error::Failed to parse srtool JSON output. Last line was: $JSON_OUTPUT"
            exit 1
          fi

          echo "::group::Srtool JSON Output"
          echo "$JSON_OUTPUT" | jq .
          echo "::endgroup::"

          # Extract paths from JSON
          WASM_PATH=$(echo "$JSON_OUTPUT" | jq -r '.runtimes.compact.wasm')
          WASM_COMPRESSED_PATH=$(echo "$JSON_OUTPUT" | jq -r '.runtimes.compressed.wasm')
          
          if [ -z "$WASM_PATH" ] || [ "$WASM_PATH" == "null" ]; then
            echo "::error::Could not extract wasm path from srtool output."
            exit 1
          fi

          # Set outputs for subsequent steps
          echo "json=$JSON_OUTPUT" >> $GITHUB_OUTPUT
          echo "wasm=$WASM_PATH" >> $GITHUB_OUTPUT
          echo "wasm_compressed=$WASM_COMPRESSED_PATH" >> $GITHUB_OUTPUT

          # Extract runtime version
          runtime_ver=$(echo "$JSON_OUTPUT" | jq -r '.runtimes.compact.subwasm.core_version.specVersion')
          echo "runtime_ver=$runtime_ver" >> $GITHUB_OUTPUT

          # Persist srtool digest
          echo "$JSON_OUTPUT" | jq > srtool-output.json

      - name: Fix permissions for cache
        run: sudo chown -R runner:docker "$GITHUB_WORKSPACE/runtime/target"

      - name: upload srtool json
        uses: actions/upload-artifact@v4
        with:
          name: srtool-json
          path: srtool-output.json

      - name: Extract runtime version and rename files
        run: |
          runtime_ver=$(jq -r '.runtimes.compact.subwasm.core_version.specVersion' srtool-output.json)
          wasm_path=$(jq -r '.runtimes.compact.wasm' srtool-output.json)
          wasm_compressed_path=$(jq -r '.runtimes.compressed.wasm' srtool-output.json)
          cp "$wasm_path" quantus-runtime-v${runtime_ver}.compact.wasm
          cp "$wasm_compressed_path" quantus-runtime-v${runtime_ver}.compact.compressed.wasm
          cp srtool-output.json quantus-runtime-srtool-output-v${runtime_ver}.json
      - name: Upload runtime artifacts
        uses: actions/upload-artifact@v4
        with:
          name: runtime
          path: |
            quantus-runtime-v*.wasm
            quantus-runtime-srtool-output-v*.json

  create-github-release:
    name: üöÄ Create GitHub Release
    needs: [calculate-next-version, build-and-package, build-runtime]
    if: always() && (needs.build-runtime.result == 'success' || needs.build-runtime.result == 'skipped') && needs.build-and-package.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      new_version: ${{ needs.calculate-next-version.outputs.new_version }}
      branch_name: ${{ needs.calculate-next-version.outputs.branch_name }}
    steps:
      - uses: actions/checkout@v4
      - if: github.event.inputs.is_runtime_upgrade == 'true'
        uses: actions/download-artifact@v4
        with:
          name: runtime
      - if: github.event.inputs.is_runtime_upgrade == 'true'
        uses: actions/download-artifact@v4
        with:
          name: srtool-json
      - if: github.event.inputs.is_runtime_upgrade == 'true'
        name: get runtime version and paths
        id: get-runtime-info
        run: |
          runtime_ver=$(jq -r '.runtimes.compact.subwasm.core_version.specVersion' srtool-output.json)
          compact_wasm_path=$(jq -r '.runtimes.compact.wasm' srtool-output.json)
          compressed_wasm_path=$(jq -r '.runtimes.compressed.wasm' srtool-output.json)
          
          # Extract just the filename, as download-artifact flattens the structure
          compact_wasm_filename=$(basename "$compact_wasm_path")
          compressed_wasm_filename=$(basename "$compressed_wasm_path")

          echo "runtime_ver=$runtime_ver" >> $GITHUB_OUTPUT
          echo "compact_wasm_path=$compact_wasm_filename" >> $GITHUB_OUTPUT
          echo "compressed_wasm_path=$compressed_wasm_filename" >> $GITHUB_OUTPUT

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Download all release assets
        uses: actions/download-artifact@v4
        with:
          path: downloaded-artifacts

      - name: Generate asset list file
        run: |
          echo "--- Directory structure of downloaded-artifacts ---"
          ls -R downloaded-artifacts
          echo "--- Finding asset files ---"
          find downloaded-artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" -o -name "*.txt" \) -print0 > asset_files.txt
          echo "--- Raw content of asset_files.txt (null characters will not be visible) ---"
          cat asset_files.txt 
          echo "--- Processed content of asset_files.txt (one file per line) ---"
          cat asset_files.txt | xargs -0 -n1
          echo "--- End of Generate asset list file step ---"

      - name: Create Git Tag
        env:
          NEW_VERSION: ${{ needs.calculate-next-version.outputs.new_version }}
          GITHUB_TOKEN: ${{ secrets.ADMIN_PAT }}
          RELEASE_BRANCH: "release/${{ needs.calculate-next-version.outputs.new_version }}"
        run: |
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"
          
          # Fetch the release branch
          git fetch origin "$RELEASE_BRANCH"
          
          # Create tag on the release branch commit
          git tag -a "$NEW_VERSION" -m "Quantus $NEW_VERSION" "origin/$RELEASE_BRANCH"
          git push origin "$NEW_VERSION"

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.ADMIN_PAT }}
          NEW_VERSION: ${{ needs.calculate-next-version.outputs.new_version }}
          COMMIT_SHA_SHORT: ${{ needs.calculate-next-version.outputs.commit_sha_short }}
          BRANCH_NAME: ${{ needs.calculate-next-version.outputs.branch_name }}
          IS_PRERELEASE: ${{ github.event.inputs.is_prerelease }}
          DRAFT_RELEASE: ${{ github.event.inputs.draft_release }}
          IS_RUNTIME_UPGRADE: ${{ github.event.inputs.is_runtime_upgrade }}
        run: |
          # Prepare release notes
          if [[ "$IS_RUNTIME_UPGRADE" == "true" ]]; then
            release_notes=$(printf "Runtime upgrade release for version %s\\nBuilt from branch: \`%s\`\\nCommit: \`%s\`\\n\\nThis release is created from the version branch. PR to main is available for review." "$NEW_VERSION" "$BRANCH_NAME" "$COMMIT_SHA_SHORT")
          else
            release_notes=$(printf "Automated release for version %s.\\nBuilt from branch: \`%s\`\\nCommit: \`%s\`\\n\\nThis release is created from the version branch. PR to main is available for review." "$NEW_VERSION" "$BRANCH_NAME" "$COMMIT_SHA_SHORT")
          fi
          
          # Write release notes to a file
          printf "%s" "$release_notes" > release_notes.txt

          # Collect asset files
          asset_args=()
          while IFS= read -r -d $'\0' file; do
            asset_args+=("$file")
          done < asset_files.txt

          # Add runtime files if this is a runtime upgrade
          if [[ "$IS_RUNTIME_UPGRADE" == "true" ]]; then
            # Get the actual paths from the downloaded artifacts
            compact_wasm_path=$(find . -name "quantus-runtime-v*.compact.wasm" -type f)
            compressed_wasm_path=$(find . -name "quantus-runtime-v*.compact.compressed.wasm" -type f)
            srtool_json_path=$(find . -name "quantus-runtime-srtool-output-v*.json" -type f)

            if [ -z "$compact_wasm_path" ] || [ -z "$compressed_wasm_path" ] || [ -z "$srtool_json_path" ]; then
              echo "Error: Could not find WASM or JSON files"
              exit 1
            fi

            asset_args+=(
              "$compact_wasm_path"
              "$compressed_wasm_path"
              "$srtool_json_path"
            )
          fi

          echo "Debug: Release notes file content:"
          cat release_notes.txt
          echo "Debug: Files to attach to release:"
          printf "'%s'\n" "${asset_args[@]}"

          gh release create "$NEW_VERSION" \
            --repo "$GITHUB_REPOSITORY" \
            --title "Quantus $NEW_VERSION" \
            --notes-file release_notes.txt \
            --target "$BRANCH_NAME" \
            $( [[ "$IS_PRERELEASE" == "true" ]] && echo "--prerelease" ) \
            $( [[ "$DRAFT_RELEASE" == "true" ]] && echo "--draft" ) \
            "${asset_args[@]}"

  create-runtime-issue:
    name: üìù Create Runtime Upgrade Issue
    needs: [create-github-release]
    if: github.event.inputs.is_runtime_upgrade == 'true' && needs.create-github-release.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create issue for runtime upgrade
        env:
          GITHUB_TOKEN: ${{ secrets.ADMIN_PAT }}
          NEW_VERSION: ${{ needs.create-github-release.outputs.new_version }}
          BRANCH_NAME: ${{ needs.create-github-release.outputs.branch_name }}
          ISSUE_BODY: |
            A new runtime upgrade has been released: [${{ needs.create-github-release.outputs.new_version }}](https://github.com/${{ github.repository }}/releases/tag/${{ needs.create-github-release.outputs.new_version }})

            ## Details
            - Release version: `${{ needs.create-github-release.outputs.new_version }}`
            - Branch: `${{ needs.create-github-release.outputs.branch_name }}`
            - PR for review: $PR_URL

            ## Next Steps
            Please review and coordinate the upgrade process.
        run: |
          # Get PR URL
          PR_URL=$(gh pr list --head "$BRANCH_NAME" --json url --jq '.[0].url')
          
          issue_title="Runtime upgrade released: $NEW_VERSION"
          gh issue create \
            --title "$issue_title" \
            --body "$ISSUE_BODY" \
            --repo "$GITHUB_REPOSITORY" \
            --label "runtime-upgrade,automated" \
            --assignee "${{ github.actor }}"